import logging
import os
from pathlib import Path
from typing import Dict

from jinja2 import Environment, FileSystemLoader

from agipack.config import AGIPackConfig, ImageConfig
from agipack.constants import AGIPACK_DOCKERFILE_TEMPLATE, AGIPACK_TEMPLATE_DIR

logging_level = os.environ.get("AGIPACK_LOGGING_LEVEL", "WARNING")
logging.basicConfig(level=logging.getLevelName(logging_level))
logger = logging.getLogger(__name__)


class AGIPack:
    """
    AGIPack: A Dockerfile generator and builder for Machine Learning Infrastructure.

    AGIPack provides a streamlined approach to generating and building Docker images
    tailored for machine learning applications. By leveraging a YAML configuration,
    users can define multiple Docker images with varying configurations, dependencies,
    and commands. This abstracts away the complexities of writing Dockerfiles manually
    and ensures a consistent, reproducible and cache-optimized build process.

    Key Features:
    - **YAML Configuration**: Define Docker images using a simple and intuitive YAML format.
    - **Template-Based Generation**: Uses Jinja2 templates to generate Dockerfiles dynamically.
    - **Custom Commands**: Offers pre-run and post-run commands for custom setup and cleanup tasks.

    Rationale:
        Building Docker images for machine learning can be a repetitive and error-prone task.
        Different projects might require different dependencies, system packages, or configurations.
        AGIPack simplifies this process by allowing users to define all their requirements in a
        structured YAML file. This not only makes the process more efficient but also ensures that
        the Docker images are consistent and reproducible.

    Usage Example:
        ```python
        from agipack import AGIPack, AGIPackConfig

        # Create an AGIPack instance
        config = AGIPackConfig.from_yaml("agibuild.yaml")
        builder = AGIPack(config)

        # Render / generate the Dockerfile
        builder.render()
        ```

    Args:
        config (AGIPackConfig): AGIPack configuration.
        output_directory (str): Output directory for the generated Dockerfiles.

    TL;DR - Yet another DSL for building machine-learning Dockerfiles.
    """

    def __init__(self, config: AGIPackConfig, output_filename: str = "Dockerfile"):
        """Initialize the AGIPack instance."""
        self.config = config
        self.output_filename = output_filename
        self.template_env = Environment(loader=FileSystemLoader(searchpath=AGIPACK_TEMPLATE_DIR))

    def _render_one(self, target: str, image_config: ImageConfig) -> str:
        """Renders / generates a Dockerfile for the given target image.
        The Dockerfile is incrementally generated by appending to the output file.

        TODO (spillai): Support writing out to a directory with multiple target
        Dockerfiles instead of a single file.

        Args:
            target (str): Target image name.
            image_config (ImageConfig): Image configuration.
        """
        template = self.template_env.get_template(AGIPACK_DOCKERFILE_TEMPLATE)
        image_dict = image_config.dict()

        # Render the Dockerfile template
        image_dict["target"] = target
        image_dict["is_prod"] = self.config.is_prod()
        image_dict["is_base_image"] = self.config.is_root(target)
        content = template.render(image_dict)

        # Write the Dockerfile to the specified output filename
        output_filename = f"{self.output_filename}"
        if not Path(output_filename).parent.exists():
            Path(output_filename).parent.mkdir(parents=True)
        try:
            mode = "w" if self.config.is_root(target) else "a"
            with open(str(Path(output_filename).absolute()), mode) as f:
                f.write(content)
        except Exception as e:
            logger.error(f"Error writing Dockerfile to {output_filename}: {e}")
            raise Exception(f"Error writing Dockerfile to {output_filename}: {e}")
        logger.info(f"ðŸ“¦ Generated Dockerfile [target={target}, filename={output_filename}]")
        return output_filename

    def render(self) -> Dict[str, str]:
        """Renders / generates Dockerfiles for all the images defined in the YAML configuration."""
        root = self.config.root()
        dockerfiles, pending = {}, {root}

        logger.info(f"ðŸ“¦ Generating Dockerfiles for {len(self.config.images)} images")
        while pending:
            # Pop the next target from the pending set
            target = pending.pop()
            logger.info(f"ðŸ“¦ Generating Dockerfile [{target}]")

            # Skip if already rendered
            if target in dockerfiles:
                continue

            # Render the Dockerfile for the current target
            image_config = self.config.images[target]
            filename = self._render_one(target, image_config)
            dockerfiles[target] = filename

            # Add children to pending
            children = self.config.children(target)
            if len(children):
                pending.update(children)

        return dockerfiles
