import logging
import os
import subprocess
from dataclasses import field
from pathlib import Path
from typing import Dict, List, Union

from jinja2 import Environment, FileSystemLoader
from pydantic.dataclasses import dataclass
from rich import print

from agipack.config import AGIPackConfig, ImageConfig
from agipack.constants import AGIPACK_DOCKERFILE_TEMPLATE, AGIPACK_ENV, AGIPACK_TEMPLATE_DIR
from agipack.version import __version__

logging_level = os.environ.get("AGIPACK_LOGGING_LEVEL", "DEBUG")
logging.basicConfig(level=logging.getLevelName(logging_level))
logger = logging.getLogger(__name__)


@dataclass
class AGIPackRenderOptions:
    """Render options for the AGIPack builder."""

    filename: Union[str, Path] = field(default="Dockerfile")
    """Output filename for the generated Dockerfile."""

    env: str = field(default=AGIPACK_ENV)
    """AGIPack environment to use for the build."""

    skip_base_builds: bool = field(default=False)
    """Skip building the base images."""

    def is_prod(self) -> bool:
        """Check if the build is for production."""
        return self.env == "prod"


class AGIPack:
    """
    AGIPack: A Dockerfile generator and builder for Machine Learning Infrastructure.

    AGIPack provides a streamlined approach to generating and building Docker images
    tailored for machine learning applications. By leveraging a YAML configuration,
    users can define multiple Docker images with varying configurations, dependencies,
    and commands. This abstracts away the complexities of writing Dockerfiles manually
    and ensures a consistent, reproducible and cache-optimized build process.

    Key Features:
    - **YAML Configuration**: Define Docker images using a simple and intuitive YAML format.
    - **Template-Based Generation**: Uses Jinja2 templates to generate Dockerfiles dynamically.
    - **Custom Commands**: Offers pre-run and post-run commands for custom setup and cleanup tasks.

    Rationale:
        Building Docker images for machine learning can be a repetitive and error-prone task.
        Different projects might require different dependencies, system packages, or configurations.
        AGIPack simplifies this process by allowing users to define all their requirements in a
        structured YAML file. This not only makes the process more efficient but also ensures that
        the Docker images are consistent and reproducible.

    Usage Example:
        ```python
        from agipack import AGIPack, AGIPackConfig

        # Create an AGIPack instance
        config = AGIPackConfig.from_yaml("agibuild.yaml")
        builder = AGIPack(config)

        # Render / generate the Dockerfile
        builder.render(filename="Dockerfile")
        ```

    Args:
        config (AGIPackConfig): AGIPack configuration.
        output_directory (str): Output directory for the generated Dockerfiles.

    TL;DR - Yet another DSL for building machine-learning Dockerfiles.
    """

    def __init__(self, config: AGIPackConfig):
        """Initialize the AGIPack instance."""
        self.config = config
        self.template_env = Environment(loader=FileSystemLoader(searchpath=AGIPACK_TEMPLATE_DIR))

    def _render_one(self, target: str, image_config: ImageConfig, options: AGIPackRenderOptions) -> str:
        """Renders / generates a Dockerfile for the given target image.
        The Dockerfile is incrementally generated by appending to the output file.

        TODO (spillai): Support writing out to a directory with multiple target
        Dockerfiles instead of a single file.

        Args:
            target (str): Target image name.
            image_config (ImageConfig): Image configuration.
            options (AGIPackRenderOptions): Render options.
        """
        template = self.template_env.get_template(AGIPACK_DOCKERFILE_TEMPLATE)
        image_dict = image_config.dict()

        # Render the Dockerfile template
        image_dict["target"] = target
        if options.skip_base_builds:
            image_dict["is_base_image"] = False
        else:
            image_dict["is_base_image"] = self.config.is_root(target)
        image_dict["is_prod"] = options.is_prod()
        image_dict["agipack_version"] = __version__
        content = template.render(image_dict)

        # Write the Dockerfile to the specified output filename
        output_filename = f"{options.filename}"
        if not Path(output_filename).parent.exists():
            Path(output_filename).parent.mkdir(parents=True)
        try:
            mode = "w" if self.config.is_root(target) else "a"
            with open(str(Path(output_filename).absolute()), mode) as f:
                f.write(content)
        except Exception as e:
            logger.error(f"Error writing Dockerfile to {output_filename}: {e}")
            raise Exception(f"Error writing Dockerfile to {output_filename}: {e}")
        logger.info(f"ðŸ“¦ Generated Dockerfile [target={target}, filename={output_filename}]")
        return output_filename

    def render(self, **kwargs) -> Dict[str, str]:
        """Renders / generates Dockerfiles for all the images defined in the YAML configuration.

        Args:
            kwargs: Optional arguments for the render process, see AGIPackRenderOptions for details.

        Returns:
            Dict[str, str]: Dictionary of target image names and their corresponding Dockerfile paths.
        """
        root = self.config.root()
        dockerfiles, pending = {}, {root}

        logger.info(f"ðŸ“¦ Generating Dockerfiles for {len(self.config.images)} images")
        while pending:
            # Pop the next target from the pending set
            target = pending.pop()
            logger.info(f"ðŸ“¦ Generating Dockerfile [{target}]")

            # Skip if already rendered
            if target in dockerfiles:
                continue

            # Render the Dockerfile for the current target
            image_config = self.config.images[target]
            options: AGIPackRenderOptions = AGIPackRenderOptions(**kwargs)
            filename = self._render_one(target, image_config, options)
            dockerfiles[target] = filename

            # Add children to pending
            children = self.config.children(target)
            if len(children):
                pending.update(children)

        return dockerfiles

    def build(self, filename: str, target: str, tags: List[str] = None, push: bool = False) -> None:
        """Builds a Docker image using the generated Dockerfile.

        Args:
            filename (str): Path to the generated Dockerfile.
            target (str): Target image name.
            tag (List[str[]): Tag for the Docker image.
            push (bool): Push the Docker image to the container repository.
        """
        logger.info(f"ðŸš€ Building Docker image for target [{target}]")
        image_config = self.config.images[target]
        if tags is not None:
            if isinstance(tags, str):
                tags = [tags]
            assert isinstance(tags, list), "tags must be a list of strings"
            image_tags = list(tags)
        else:
            image_tags = [f"{image_config.name}:{target}"]
        logger.debug(f"Image tags: {image_tags}")

        # Build the Docker image (using buildkit)
        cmd = ["docker", "build", "-f", filename, "--target", target]
        for tag in image_tags:
            cmd.extend(["-t", tag])
        cmd.append(".")

        logger.debug(f"Running command: {cmd}")
        env = os.environ.copy()
        env.update({"DOCKER_BUILDKIT": "1"})
        process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            env=env,
        )
        for line in iter(process.stdout.readline, ""):
            print(line, end="")
        process.wait()

        if process.returncode != 0:
            raise Exception(f"Failed to build image [target={target}]")

        # Push the Docker image
        if push:
            self.push(image_tags)

    def lint(self, filename: str) -> bool:
        """Lint the generated Dockerfile using hadolint.

        Args:
            filename (str): Path to the generated Dockerfile.
        """
        cmd = "docker pull hadolint/hadolint && "
        cmd += f"docker run --pull=always --rm -i hadolint/hadolint < {filename}"
        logger.info("Linting with hadolint")
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            shell=True,
        )
        process.wait()
        for line in iter(process.stdout.readline, ""):
            print(line, end="")
        return process.returncode == 0

    def push(self, tags: List[str]) -> None:
        """Pushes Docker image tags to the container repository.

        Args:
            tags (List[str]): Tags for the Docker image.
        """
        logger.info(f"ðŸš€ Pushing Docker images [{tags}]")

        # Push the Docker image
        for tag in tags:
            cmd = f"docker push {tag}"
            logger.debug(f"Running command: {cmd}")
            process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                shell=True,
            )
            for line in iter(process.stdout.readline, ""):
                print(line, end="")
            process.wait()
            if process.returncode != 0:
                raise Exception(f"Failed to push image [tag={tag}]")
